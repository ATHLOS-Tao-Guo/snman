from leuvenmapmatching.matcher.distance import DistanceMatcher
from leuvenmapmatching.map.inmem import InMemMap
from leuvenmapmatching import visualization as mmviz
import shapely as shp
from statistics import mean
import pandas as pd
import warnings


def match_linestrings(G, source, column_configs, show_test_plot=None):
    """
    Make a spatial join of the graph edges and polylines in a GeoDataFrame.
    Copy selected attributes from the GeoFDataFrame to the graph edges.

    The spatial join is made using LeuvenMapMatching:
    https://github.com/wannesm/LeuvenMapMatching

    Parameters
    ----------
    G : nx.MultiGraph
        street graph, target
    source : gpd.GeoDataFrame
        data source
    column_configs : list
        a list of dictionaries, example:
            [
                {'source_column': 'DTV_ALLE',   'target_column': 'adt_avg',         'agg': 'avg' },
                {'source_column': 'DTV_ALLE',   'target_column': 'adt_max',         'agg': 'max' },
                {'source_column': 'FROMNODENO', 'target_column': 'npvm_fromnodeno', 'agg': 'list'},
                {'source_column': 'TONODENO',   'target_column': 'npvm_tonodeno',   'agg': 'list'}
            ]
    show_test_plot : bool
        make a test plot showing the map matching process,
        generated by the leuvenmapmatching library (for debugging)

    Returns
    -------
    None
    """

    map_con = InMemMap("source", use_latlon=False, use_rtree=True, index_edges=True, crs_xy=2056)

    # please note that lv works with lat, lon (reverse order)
    for id, data in G.nodes.items():
        map_con.add_node(id, (data['y'], data['x']))
        #print((data['y'], data['x']))

    for id, data in G.edges.items():
        u = int(id[0])
        v = int(id[1])
        # only include the edges that are accessible for cars, incl. the correct direction
        if 'M>' in data['ln_desc'] or 'M-' in data['ln_desc']:
            map_con.add_edge(u,v)
        if 'M<' in data['ln_desc'] or 'M-' in data['ln_desc']:
            map_con.add_edge(v,u)

    matcher = DistanceMatcher(map_con, max_dist=30, max_dist_init=30, max_lattice_width=5, non_emitting_states=True, only_edges=True)

    def _get_nodes_of_linestring(geom):
        if isinstance(geom, shp.geometry.MultiLineString):
            geom = geom.geoms[0]
        path = geom.coords
        path = [coords[::-1] for coords in path]
        matcher.match(path)
        nodes = matcher.path_pred_onlynodes
        #print(nodes)
        return nodes

    source['nodes'] = source.apply(lambda x: _get_nodes_of_linestring(x['geometry']), axis=1)

    for config in column_configs:

        edge_values = {}
        for index, edge in source.iterrows():
            value = edge[config['source_column']]
            nodes = edge['nodes']
            if len(nodes) < 2:
                continue
            node_pairs = [nodes[i:i+2] for i in range(len(nodes)-1)]
            for node_pair in node_pairs:
                u = node_pair[0]
                v = node_pair[1]
                if edge_values.get((u,v)) is None:
                    edge_values[(u,v)] = []
                edge_values[(u,v)].append(value)

        for id, data in G.edges.items():
            if config['agg'] == 'avg':
                data[config['target_column'] + '_forward']  = mean(edge_values.get(id[:2], [0]))
                data[config['target_column'] + '_backward'] = mean(edge_values.get(id[:2][::-1], [0]))
            if config['agg'] == 'max':
                data[config['target_column'] + '_forward']  = max(edge_values.get(id[:2], [0]))
                data[config['target_column'] + '_backward'] = max(edge_values.get(id[:2][::-1], [0]))
            elif config['agg'] == 'list':
                data[config['target_column'] + '_forward']  = str(edge_values.get(id[:2]))
                data[config['target_column'] + '_backward'] = str(edge_values.get(id[:2][::-1]))

    if show_test_plot is not None:
        source_test_path = source.query(show_test_plot).reset_index().iloc[0]['geometry']
        path = [coords[::-1] for coords in list(source_test_path.coords)]
        matcher.match(path)
        print(matcher.path_pred_onlynodes)
        mmviz.plot_map(map_con, matcher=matcher,show_labels=False, show_matching=True, show_graph=True)


def match_sensors(G, sensors_df):
    """
    Assign traffic sensors to edges in the street graph. Must be used with OSM graph.

    Parameters
    ----------
    G : nx.MultiDiGraph
        OSM graph
    sensors_df : pd.DataFrame
        sensors and their osm links

    Returns
    -------
    None
    """

    s = sensors_df.copy()
    s['id'] = s.index
    s = s.set_index(['u', 'v', 'osmid']).sort_index()

    for uvk, data in G.edges.items():
        u, v, k = uvk

        i_forward = (u, v, data['osmid'])
        if i_forward in s.index:
            data['sensors_forward'] = [s.loc[i_forward]['id']]
        else:
            data['sensors_forward'] = []

        i_backward = (v, u, data['osmid'])
        if i_backward in s.index:
            data['sensors_backward'] = [s.loc[i_backward]['id']]
        else:
            data['sensors_backward'] = []


def match_pt(G, pt_network):
    """
    Matches the public transport network onto the street network.

    Parameters
    ----------
    G: nx.MultiGraph
        street graph
    pt_network: gpd.GeoDataFrame
        Linestrings of public transport routes, based on the open dataset of ZVV
        "Linien des Ã¶ffentlichen Verkehrs (OGD) (kantonaler Datensatz)"
        https://data.stadt-zuerich.ch/dataset/ktzh_linien_des_oeffentlichen_verkehrs__ogd_,
        with following additional columns:
            * TYPE (Tram, Bus, Nightbus, Microbus)
            * ALIGNMENT (tunnel, <None>)
    """

    # Add buffers around the pt routes
    pt_network_buffers = pt_network.copy()
    pt_network_buffers.geometry = pt_network_buffers.geometry.buffer(15, resolution=16)

    for edge in G.edges(data=True, keys=True):

        edge_geometry = edge[3]['geometry']

        # Get all pt routes whose buffers intersect with this edge
        pt_routes = pt_network_buffers[
            pt_network_buffers.intersects(edge_geometry).tolist()
            and pt_network_buffers['ALIGNMENT'] != 'tunnel'
        ].copy()

        if len(pt_routes) == 0:
            continue

        # Calculate the overlapping length
        with warnings.catch_warnings():
            # we suppress warnings due to a known issue in the intersection function
            # see here: https://github.com/shapely/shapely/issues/1345
            warnings.simplefilter("ignore")
            pt_routes['intersection_length_prop'] = [
                edge_geometry.intersection(pt_route).length / edge_geometry.length if edge_geometry.length != 0 else 0
                for pt_route in pt_routes.geometry
            ]

        # Keep only those that overlap over a substantial part
        pt_routes = pt_routes[pt_routes['intersection_length_prop'] > 0.7]

        edge[3]['pt_routes'] = str(pt_routes.LINIENNUMM.tolist())
        # TODO: Distinguish directions of pt lines
        edge[3]['pt_tram'] = pt_routes['TYPE'].eq('Tram').any() * 1
        edge[3]['pt_bus'] = pt_routes['TYPE'].eq('Bus').any() * 1
        edge[3]['pt_mcrbus'] = pt_routes['TYPE'].eq('Microbus').any() * 1

